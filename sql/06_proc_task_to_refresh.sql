-- Procedure: DEV_DBM.INGESTION_METADATA.TASK_TO_REFRESH_TARGET_TABLE
-- Creates/updates a task in <DB>.RAW to MERGE from RAW view into TARGET table

CREATE OR REPLACE PROCEDURE DEV_DBM.INGESTION_METADATA.TASK_TO_REFRESH_TARGET_TABLE(
  TABLENAMEINPUT VARCHAR,
  SCHEMANAMEINPUT VARCHAR,
  DBNAME VARCHAR
)
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS OWNER
AS '
DECLARE 
  tablename VARCHAR;
  has_pk INT;
  all_columns STRING;
  value_alias STRING;
  set_columns STRING;
  on_predicate STRING;
  partition_by_cols STRING;
  last_modified_col STRING;
  v_query STRING;
BEGIN
  -- Ensure metadata is current (no-op in new model, kept for compatibility)
  -- In the new design we read directly from VW_METADATA

  -- Compute lists from metadata
  SELECT LISTAGG(''t.''||COLUMNNAME||'' = b.''||COLUMNNAME, '', '') INTO :set_columns
  FROM DEV_DBM.INGESTION_METADATA.VW_METADATA
  WHERE UPPER(DBNAME)=UPPER(:DBNAME) AND UPPER(SCHEMANAME)=UPPER(:SCHEMANAMEINPUT) AND UPPER(TABLENAME)=UPPER(:TABLENAMEINPUT);

  SELECT LISTAGG(COLUMNNAME, '', '') INTO :all_columns
  FROM DEV_DBM.INGESTION_METADATA.VW_METADATA
  WHERE UPPER(DBNAME)=UPPER(:DBNAME) AND UPPER(SCHEMANAME)=UPPER(:SCHEMANAMEINPUT) AND UPPER(TABLENAME)=UPPER(:TABLENAMEINPUT);

  SELECT LISTAGG(''b.''||COLUMNNAME, '', '') INTO :value_alias
  FROM DEV_DBM.INGESTION_METADATA.VW_METADATA
  WHERE UPPER(DBNAME)=UPPER(:DBNAME) AND UPPER(SCHEMANAME)=UPPER(:SCHEMANAMEINPUT) AND UPPER(TABLENAME)=UPPER(:TABLENAMEINPUT);

  SELECT COUNT(1) INTO :has_pk
  FROM DEV_DBM.INGESTION_METADATA.VW_METADATA
  WHERE UPPER(DBNAME)=UPPER(:DBNAME) AND UPPER(SCHEMANAME)=UPPER(:SCHEMANAMEINPUT) AND UPPER(TABLENAME)=UPPER(:TABLENAMEINPUT) AND PRIMARYKEYFLAG;

  IF (NVL(:has_pk,0) = 0) THEN
    -- If no PK flagged, use all columns as pseudo-key for idempotency
    SELECT LISTAGG(''NVL(t.''||COLUMNNAME||'', NVL(b.''||COLUMNNAME||'', '''''''')) = NVL(b.''||COLUMNNAME||'', '''''''')'', '' AND '')
      INTO :on_predicate
    FROM DEV_DBM.INGESTION_METADATA.VW_METADATA
    WHERE UPPER(DBNAME)=UPPER(:DBNAME) AND UPPER(SCHEMANAME)=UPPER(:SCHEMANAMEINPUT) AND UPPER(TABLENAME)=UPPER(:TABLENAMEINPUT);

    SELECT LISTAGG(COLUMNNAME, '', '') INTO :partition_by_cols
    FROM DEV_DBM.INGESTION_METADATA.VW_METADATA
    WHERE UPPER(DBNAME)=UPPER(:DBNAME) AND UPPER(SCHEMANAME)=UPPER(:SCHEMANAMEINPUT) AND UPPER(TABLENAME)=UPPER(:TABLENAMEINPUT);
  ELSE
    SELECT LISTAGG(''NVL(t.''||COLUMNNAME||'', NVL(b.''||COLUMNNAME||'', '''''''')) = NVL(b.''||COLUMNNAME||'', '''''''')'', '' AND '')
      INTO :on_predicate
    FROM DEV_DBM.INGESTION_METADATA.VW_METADATA
    WHERE UPPER(DBNAME)=UPPER(:DBNAME) AND UPPER(SCHEMANAME)=UPPER(:SCHEMANAMEINPUT) AND UPPER(TABLENAME)=UPPER(:TABLENAMEINPUT) AND PRIMARYKEYFLAG;

    SELECT LISTAGG(COLUMNNAME, '', '') INTO :partition_by_cols
    FROM DEV_DBM.INGESTION_METADATA.VW_METADATA
    WHERE UPPER(DBNAME)=UPPER(:DBNAME) AND UPPER(SCHEMANAME)=UPPER(:SCHEMANAMEINPUT) AND UPPER(TABLENAME)=UPPER(:TABLENAMEINPUT) AND PRIMARYKEYFLAG;
  END IF;

  v_query := ''CREATE OR REPLACE TASK ''||:DBNAME||''.RAW.''||''TargetRefresh_''||:TABLENAMEINPUT||
             '' WAREHOUSE = PAYMENTS_S ''||
             '' WHEN SYSTEM$STREAM_HAS_DATA(''''||:DBNAME||''.RAW.ST_RAW_''||:TABLENAMEINPUT||'''''') AS\n''||
             ''MERGE INTO ''||:DBNAME||''.TARGET.''||:TABLENAMEINPUT||'' t USING (SELECT * FROM ''||:DBNAME||''.RAW.VW_ST_''||:TABLENAMEINPUT||'' WHERE NOT (METADATAACTION = ''''DELETE'''' ) QUALIFY ROW_NUMBER() OVER (PARTITION BY ''||:partition_by_cols||'' ORDER BY RAW_ROW_CRE_DT DESC) = 1) b ON ''||:on_predicate||
             '' WHEN MATCHED THEN UPDATE SET ''||:set_columns||'', t.RAW_ROW_CRE_DT = b.RAW_ROW_CRE_DT, t.FILENAME = b.FILENAME WHEN NOT MATCHED THEN INSERT (''||:all_columns||'', RAW_ROW_CRE_DT, FILENAME) VALUES (''||:value_alias||'', b.RAW_ROW_CRE_DT, b.FILENAME);'';

  EXECUTE IMMEDIATE :v_query;
  EXECUTE IMMEDIATE ''ALTER TASK ''||:DBNAME||''.RAW.''||''TargetRefresh_''||:TABLENAMEINPUT||'' RESUME'';

  RETURN ''Task Created'';
END';